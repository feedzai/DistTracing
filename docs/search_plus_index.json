{"./":{"url":"./","title":"Identification","keywords":"","body":"Identification "},"changelog.html":{"url":"changelog.html","title":"Changelog","keywords":"","body":"Changelog "},"DESCRIPTION.html":{"url":"DESCRIPTION.html","title":"Start Here","keywords":"","body":"Description This project is a simplified API for tracing Java based distributed systems, as well as an implementation based on the OpenTracing instrumentation framework and the Jaeger tracing engine. In this book you will first find a small explanation of the tracing model, then a high-level description of the APIs and some instruction on when to use each API. Index Model API Description API Description With ID API Description With Context Engines Promise "},"MODEL.html":{"url":"MODEL.html","title":"Model","keywords":"","body":"Tracing Model The project's API makes no assumption on the model used by it's implementation. However, the main OpenTracing based implementation relies on the Span model. Spans and Trees The Span nodel is nothing more than a tree of nodes called Spans. Each Span is simply a small data structure that represents a fraction of the execution of any given request. This model was originally designed for distributed systems based on RPC, and as such the edges represented service-activation, however you can view them as the activation of a new service, method, fraction of code, etc. Hierarchical Structure Given that it's based on a tree, each trace will have a root Span that represents the beginning of a request's execution, think of this first span as the entry-point. Calls to other traced methods will become children of the root, calls from the children to other methods will become the children's children and so on. In the end a trace will resemble a distributed call tree that shows you the request path. Span Metadata Spans contain a traceID, a spanID and parentId and key-value pairs called annotations. The annotations can be defined by the programmer, however there are two annotations which are present in every span: the start and end timestamp. This means that through tracing it is possible to view how long the request spent in each component. Visualization The simplest way to view a trace is by looking at the span tree, however a Gantt Chart is the preferred visualization, as it shows both the causality relations between spans across time. Below is an example of a Gantt Chart that represents the trace of a request in Pulse. "},"API-DESC.html":{"url":"API-DESC.html","title":"API Description","keywords":"","body":"Tracing API Description In this page we will describe the different API methods and how they interact with each other. When to use this API This is the base API for systems that don't require tracing across thread context switches. If your system requires that please check: Tracing API With Id Description for systems that have an application level eventID and don't trace across process boundaries. Tracing API With Context Description for systems that have no such ID and require explicit propagation of the tracing context, or trace across process boundaries. Main Types of Methods The API is comprised of two main classes of methods Tracing#newTrace and Tracing#addToTrace. As the name suggests the first method will create a new trace by wrapping the traced operation as a Span with no parent, the latter will wrap the operation in a Span that is a child of the one of the ongoing traces. Most tracing tools ignore this distinction and simply make the first call to the tracing API the root. However, this relies on the assumption that the each request has its own thread, or at least that the entry point of the system does not reuse threads. Since we cannot always make that assumption we decided to provide a clear way to begin a new trace. These two types have two things in common: both take a lambda (the traced method) and a String (the span name/description) as parameters in all methods. New Trace These methods should be used to trace the first method executed by a new request. Add To Trace Whenever you want to continue a pre-existing trace, you should use methods called Tracing#addToTrace(..). Examples Starting a Trace Let's say you have a method called onMessage(Message msg) in which you start processing a new request. In this situation all you have to do is: Example 1 - Starting a Trace void onMessage(Message msg) { Tracing.newTrace(() -> processMessage(msg), \"Process Request\"); } In the examples, the methods have no return values, but the API provides overloads for tracing functions that return any type of value. Continuing a trace Continuing a trace is a bit trickier than starting it, since it requires accessing the current trace context in order to add the new Span as a child. In cases with no multithreading it's very simple, as the Tracing library stores the trace context in thread local variables, as such all you have to do is use the base method. Example 2 - Parent and child Spans in the same thread. void processMessage(Message msg) { Tracing.addToTrace(() -> processFirstPart(msg), \"Process First Part\") } The library will magically attach the new Span to the current trace. "},"API-DESC-ID.html":{"url":"API-DESC-ID.html","title":"API Description With ID","keywords":"","body":"Tracing API With ID Description In this page we will describe the different API methods and how they interact with each other when the traced software has an application-level eventID. When to use this API This API allows you to map your own application-level eventID to the traceID and avoid having to explicitly propagate the context object. Use this API if you: Trace operations across thread boundaries and have an an application level ID assigned to each request. Don't trace across process boundaries. Don't have multiple threads working on the same request at the same time. How it differs from the base Tracing API This API exposes the same functionality as Tracing API, with slight differences: All methods take in an additional parameter eventID allowing you to map the tracing engine generated traceID with your application specific ID. Examples Starting a Trace Let's say you have a method called onMessage(Message msg) in which you start processing a new request. In this situation you have one option. Example 1 - Starting a Trace void onMessage(Message msg) { Tracing.newTrace(() -> processMessage(msg), \"Process Request\", msg.getId()); } In the examples, the methods have no return values, but the API provides overloads for tracing functions that return any type of value. Continuing a trace Continuing a trace is a bit trickier than starting it, since it requires accessing the current trace context in order to add the new Span as a child. Example 2 - Parent and child Spans in the different thread but there is an application specific ID. In this case we have to explicitly tell the Tracing library which trace this span belongs to. If the traced application marks each new request with an ID, it becomes easy. void processMessage(Message msg) { threadPool.submit(() -> Tracing.addToTrace(() -> processFirstPart(msg), \"Process First Part\", msg.getId())); } The library will find the trace associated to this ID and add the new span as a child. Keep in mind that to use this method you must have mapped the application specific ID to the traceID by calling newTrace(.., String eventID) "},"API-DESC-CTX.html":{"url":"API-DESC-CTX.html","title":"API Description With Context","keywords":"","body":"Tracing API With Context Description In this page we will describe the different API methods and how they interact with each other in situations where passing context explicitly is necessary. When to use this API This API allows you to explicitly pass the tracing context between methods in the form of a TraceContext object. Use this API if you: Trace operations across multiple threads and don't have an application level eventID assigned to each request. Trace operations that are processed by multiple threads at the same time. Trace operations across process boundaries. How it differs from the base Tracing API This API exposes the same functionality as Tracing API with slight differences: The addToTrace methods receive a TraceContext that represents the context that will be the parent of this Span. Examples Starting a Trace Let's say you have a method called onMessage(Message msg) in which you start processing a new request. In this situation, since there is no parent, you do not have to propagate context. Example 1 - Starting a Trace. void onMessage(Message msg) { Tracing.newTrace(() -> processMessage(msg), \"Process Request\"); } In the examples, the methods have no return values, but the API provides overloads for tracing functions that return any type of value. Continuing a trace Continuing a trace is a bit trickier than starting it, since it requires accessing the current trace context in order to add the new Span as a child. Example 1 - Parent and child Spans in the different thread pass context explicitly This case requires you to explicitly pass the TraceContext to the new span. void processMessage(Message msg) { TraceContext context = Tracing.getTraceContext(); threadPool.submit(() -> Tracing.addToTrace(() -> processFirstPart(msg), \"Process Request\", context)); } Here the library will grab the current thread's tracing context and store it in a TraceContext object that you can pass when tracing the next part of the execution. Note that obtaining the current context must be done before switching context, i.e., you cannot do it inside the lambda. "},"ENGINES.html":{"url":"ENGINES.html","title":"Engines","keywords":"","body":"Engines This library provides the following implementations of our API: JaegerTracingEngine - This implementation performs distributed tracing and uses Jaeger as its tracing backend. NoopTracingEngine - This engine should be used when users wish to completely ignore all tracing instrumentation. Using this engine is the closest possible thing to removing all instrumentation code. LoggingTracingEngine - This engine logs each tracepoint to a file in the working environment. Keep in mind that this does not preserve the causal relation between tracepoints. The format of each log entry is the following: description, optional(eventId), timestamp, latency(ns) Writing Custom Engines Writing a custom engine is as simple as implementing any of our APIs. Keep in mind that if you wish to add another distributed tracing backend (such as Zipkin) we already provide an OpenTracing based abstract implementation in Tracing-Lib, which might make the process easier. "},"PROMISE.html":{"url":"PROMISE.html","title":"Promise","keywords":"","body":"Promises In most applications it's faster to do certain things asynchronously. Promises allow us to create an object that represents an asynchronous computation and may finish successfully or with an exception. Tracing calls to Promises does not allow us to capture the full duration of the asynchronous execution, so we have to attach a method to the promises that close the Span whenever it finishes. Since different systems can implement their own promise classes we provide a simple interface that can be implemented by the traced systems in order to make their Promise implementations compatible with our tracing API. The interface has two simple methods: Promise#OnComplete(Consumer) that executes if the promise completes successfully. Promise#OnError(Consumer) that executes if the promise completes exceptionally. These methods allow us to pass a function that takes a promise as argument and returns it, which closes the span whenever it should be completed. How to use this in your projects Make the classes that represent asynchronous computations implement the Promise API. Can I use this with CompletableFuture? No, since the tracing API for Promises requires that the objects using it implement the Promise interface, which can't be done with Completable Future. However, all of the tracing APIs have overloads that provide the same functionality for methods returning CompletableFuture Example Let's say we have a long running computation that we want to trace and takes 500ms. The following code would fail to trace the full execution Example 1 - What not to do. void onMessage(Message msg) { Promise promise = Tracing.newTrace(() -> longRunningComputation(msg), \"Process Request\", msg.getId()); } This will close the span when the call finishes and not when the computation finishes! Example 1 - Doing it right. void onMessage(Message msg) { Promise promise = Tracing.newTracePromise(() -> longRunningComputation(msg), \"Process First Part\", msg.getId()); } This will close the span when Promise#OnComplete or Promise#OnError finishes. "},"TRACECTX.html":{"url":"TRACECTX.html","title":"TraceContext","keywords":"","body":"TraceContext Since our API is implementation agnostic, we can't use a vendor specific Span object whenever it's useful to refer to the trace context directly. To counter that we designed an immutable interface that is parametrized with the implementation's context object. This means that one TraceContext object holds one and only one implementation specific context objec. For our OpenTracing implementation we used this interface to wrap the Span object by creating a class SpanTracingContext that extends TracingContext User's can implement their own versions of the TracingContext to fit whatever their needs might be. "}}